% ! TeX root = ../../thesis.tex
\chapter{Analisi e Progettazione}
\label{chapter:analysis}
In questo secondo capitolo viene presentata l'analisi dei requisiti e il \textit{design} del sistema.
%
Nei primi due paragrafi vengono elencati i requisiti del sistema ed è descritto il dominio applicativo.
%
Il terzo paragrafo è dedicato al \textit{design} dell'applicativo: si parte da una visione architetturale e a seguire si dettagliano le parti di \textit{design} più rilevanti al fine di chiarificare la logica con cui è stato implementato il sistema.

\section{Requisiti}
Come già anticipato, lo scopo della tesi è realizzare un sistema antiplagio automatico in grado d'individuare eventuali porzioni di codice copiato nei progetti \textit{software} del corso di Programmazione ad Oggetti dell'Università di Bologna.

Di seguito vengono descritti, per punti, i requisiti del sistema, suddivisi tra requisiti \textit{funzionali} e \textit{non funzionali}.

\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Il sistema riceve in \textit{input} un insieme di progetti di cui si vuole verificare l'autenticità, detto \textbf{\textit{Submission}}, e un insieme di progetti con cui confrontarli, detto \textbf{\textit{Corpus}};
    
    \item Il confronto viene effettuato tra progetti sviluppati nello stesso linguaggio di programmazione.
    
    \item I progetti sono sviluppati in linguaggio Java e mantenuti in \textit{repository} pubbliche su \textit{GitHub} e \textit{Bitbucket}\footnote{
        \href{https://github.com}{\textit{GitHub}} e \href{https://bitbucket.org}{\textit{Bitbucket}} sono due tra i più conosciuti servizi di \textit{hosting} per progetti \textit{software} che utilizzano sistemi di controllo di versione decentralizzati, come \href{https://git-scm.com}{Git}.
    }. Si assume che i progetti passati siano tempo-invarianti: dal momento in cui vengono corretti, le rispettive \textit{repository} sono archiviate e mai più modificate;

    \item Il sistema deve fornire in \textit{output} le sezioni di codice che, con un determinato livello di accuratezza, ha stabilito essere simili.
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
    \item L'algoritmo per determinare la similarità, così come le metriche utilizzate, devono essere interscambiabili e facilmente estendibili;
    \item Le informazioni estrapolate dai sorgenti sono salavate in modo tale da essere riutilizzate nelle analisi successive di altri progetti;
    \item \`E necessario che il sistema impieghi un tempo "ragionevole" per effettuare la computazione;
\end{itemize}

\section{Analisi e modello del dominio}
% descrizione session?
Il sistema deve essere in grado, a partire da un insieme di \textit{repository}, corrispondenti a progetti coerenti per linguaggio di programmazione, di estrarne una rappresentazione confrontabile (\textit{SourceRepresentation}) medianti opportuni algoritmi di analisi (\textit{Analyzer}).
%
Ciascuna coppia di rappresentazioni intermedie deve essere successivamente confrontata da algoritmi di rilevamento di somiglianze (\textit{PlagiarismDetector}) al fine di poter determinare eventuali parti di codice duplicato e/o somiglianze, generando infine dei \textit{report}.

Gli elementi costitutivi il problema sono sintetizzati in \Cref{img:02-domain}.

La principale difficoltà sarà individuare tecniche di analisi e di rilevamento delle somiglianze che siano robuste, ovvero permettano d'identificare casi dii copiature anche se lo sviluppatore ha effettuato modifiche per oscurarle.
%
Particolare attenzione dovrà essere posta sulla progettazione dei componenti per l'analisi e per il confronto, in quanto, data la natura del sistema, possono dover cambiare frequentemente ed essere fortemente configurabili.
%
Inoltre, il requisito non funzionale sulle \textit{performance} richiederà un'analisi dei tempi di esecuzione non appena il sistema sarà completato.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{resources/img/02-domain.pdf}
    \caption{Schema UML delle classi dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro.}
    \label{img:02-domain}
\end{figure}

\section{\textit{Design}}

\subsection{Architettura}
% manca la trattazione degli input...
L'architettura del sistema è così organizzata: \textbf{\textit{AntiPlagiarismSession}} è l'interfaccia responsabile della logica dell'applicazione e rappresenta una specifica sessione, dove per sessione si intende l'entità che, una volta opportunamente configurata con gli opportuni analizzatori, \textit{provider} di progetti e \textit{output}, esegue la logica dell'applicazione.

Gli \textbf{\textit{Output}} rappresentano le risorse su cui andare a rappresentare i risultati ottenuti, mentre il \textbf{\textit{RepositoryProvider}} rappresenta la strategia con cui recuperare i progetti su cui effettuare l'analisi.

Il confronto e l'analisi dei sorgenti vengono effettuati, rispettivamente, dal \textbf{\textit{PlagiarismDetector}} e dall'\textbf{\textit{Analyzer}}, che incapsula la specifica strategia utilizzata e demanda a \textbf{\textit{KnoledgeBaseRepository}} il salvataggio e il recupero delle rappresentazioni dei sorgenti già precedentemente analizzati e, perciò, salvati.

Questa architettura permetterebbe facilmente l'aggiunta di un nuovo \textbf{\textit{Output}} e di poter cambiare sia la strategia per recuperare i progetti, sia la logica con cui questi vengono processati.

In \Cref{img:02-architecture} è esemplificato il diagramma UML architetturale.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{resources/img/02-achitecture.pdf}
    \caption{Schema UML architetturale del sistema.}
    \label{img:02-architecture}
\end{figure}

\subsection{\textit{Design} dettagliato}
In questa sezione si presenta in modo dettagliato le singole componenti del sistema.

\subsubsection*{\textit{Provider} dei progetti}
Per quanto concerne i \textit{provider} di \textit{repository}, ovvero i componenti che devono recuperare i sorgenti dei progetti da \textit{repository} pubbliche da \textit{GitHub} e/o da \textit{Bitbucket}, si è scelto un \textit{design} che permettesse il massimo riuso degli elementi comuni, aderendo a uno schema interfaccia - classe astratta - classe concreta.

Dopo una prima analisi delle \textit{API} pubbliche dei due servizi di \textit{hosting} si è convenuto di permettere di recuperare i progetti mediante due metodi: un \textit{link} diretto alla \textit{repository}, oppure mediante un criterio di ricerca, che verrà descritto nel dettaglio più avanti.

Inoltre, viste le limitazioni in termini di richieste che i due servizi espongono e la conseguente necessità di autenticarsi mediante degli opportuni \textit{token} per effettuare le richieste REST, si è optato di demandare la logica di recupero dei suddetti \textit{token} di autenticazione all'interfaccia \textit{TokenSupplierStrategy} che fa da \textit{Strategy}. 
%
L'implementazione di default ricerca tra variabili d'ambiente, ma questo approccio permette al sistema di essere estensibile.
% devo descrivere cosa fa strategy? magari una nota a piè di pagina...
%
La creazione dei provider avviene per mezzo di due \textit{static factory}, incapsulate all'interno dei due \textit{provider}, in modo da permettere di ottenere un oggetto \textit{provider} anche senza autenticazione.
%
Nonostante questo sia in genere sconsigliato, può essere utile in fase di \textit{testing} e per permettere di testare il sistema anche con la CI attiva.
% consider static factory effective kotlin
% riferimento alla CI

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{resources/img/02-provider.pdf}
    \caption{Schema UML dei provider.}
    \label{img:02-provider}
\end{figure}
